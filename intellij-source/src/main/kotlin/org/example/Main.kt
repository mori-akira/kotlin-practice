/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import org.example.basic.Android
import org.example.basic.ClassSyntax
import org.example.basic.Collection
import org.example.basic.Computation
import org.example.basic.Dog
import org.example.basic.Syntax
import org.example.variableKotlinFunction.Accessor
import org.example.variableKotlinFunction.KotlinSentence
import org.example.variableKotlinFunction.User1
import org.example.variableKotlinFunction.User2
import org.example.variableKotlinFunction.MyNumber

class App {
    val greeting: String
        get() {
            return "Hello World!"
        }
}

fun main() {
    println(App().greeting)
    greet().let { println(it) }
    syntax()
    collection()

    kotlinSentence()
    accessor()
    dataClass()
    functionalType()
    expandFunction()
    scopeFunction()
    operatorOverload()
}

fun greet(): String {
    return "Hello from the greet function!"
}

fun syntax() {
    println()
    println("syntax: variable")
    Syntax().variable()

    println()
    println("syntax: variable with type")
    Syntax().variableWithType()

    println()
    println("syntax: function definition")
    print(message = Syntax().functionDefinition("Kotlin"))

    println()
    println("syntax: variable sentence")
    val syntax = Syntax()
    syntax.variableSentence()

    println()
    println("syntax: class syntax")
    val classSyntax = ClassSyntax("Kotlin", 1)
    classSyntax.showParam()

    println()
    println("syntax: inheritance")
    val dog = Dog("Buddy", 3)
    dog.showInfo()
    dog.cries()
    val android = Android()
    android.showName()

    println()
    println("syntax: interface")
    val computation = Computation()
    println("Computation result: ${computation.compute()}")
}

fun collection() {
    println()
    println("collection: list")
    Collection().list()

    println()
    println("collection: map")
    Collection().map()

    println()
    println("collection: set")
    Collection().set()
}

fun kotlinSentence() {
    println()
    println("kotlinSentence")
    val kotlinSentence = KotlinSentence()
    kotlinSentence.printOddOrEven(7)
    kotlinSentence.printOddOrEven(10)
    kotlinSentence.printRemainderDividedByThree(10)
    kotlinSentence.printRemainderDividedByThree(11)
    kotlinSentence.printRemainderDividedByThree(12)
}

fun accessor() {
    println()
    println("accessor")
    val accessor = Accessor(null)
    println("Accessor field1: ${accessor.field1}")
    accessor.field1 = "Kotlin"
    println("Accessor field1: ${accessor.field1}")
    // getter、setterを直接呼び出すことはできない
    // accessor.setField1("Java")
    // println("Accessor field1: ${accessor.getField1()}")

    println("Accessor field2: ${accessor.field2}")

    try {
        println("Accessor field3: ${accessor.field3}")
    } catch (e: UninitializedPropertyAccessException) {
        println("Accessor field3 is not initialized yet.")
        e.printStackTrace(System.out)
    }

    println("Accessor field4: ${accessor.field4}")
    accessor.field4 = "NewValue"
    println("Accessor field4: ${accessor.field4}")
}

fun dataClass() {
    println()
    println("dataClass")
    val user1_1 = User1(1)
    val user1_2 = User1(1)
    println("user1_1.toString(): ${user1_1.toString()}")
    println("user1_1 == user1_2: ${user1_1 == user1_2}")
    println("user1_1.equals(user1_2): ${user1_1.equals(user1_2)}")
    println("user1_1.hashCode(): ${user1_1.hashCode()}")
    println("user1_2.hashCode(): ${user1_2.hashCode()}")

    val user2_1 = User2(1)
    val user2_2 = User2(1)
    println("user2_1.toString(): ${user2_1.toString()}")
    println("user2_1 == user2_2: ${user2_1 == user2_2}")
    println("user2_1.equals(user2_2): ${user2_1.equals(user2_2)}")
    println("user2_1.hashCode(): ${user2_1.hashCode()}")
    println("user2_2.hashCode(): ${user2_2.hashCode()}")

    println("user2_1.component1(): ${user2_1.component1()}")
    println("user2_1.component2(): ${user2_1.component2()}")

    val (id, name) = user2_1
    println("Destructured user2_1: id=$id, name=$name")
    println("user2_1.copy(): ${user2_1.copy()}")
}

typealias Operation = (Int, Int) -> Int

fun functionalType() {
    println()
    println("functionalType")
    val lambda1: (Int, Int) -> Int = { a: Int, b -> a + b }
    println("Lambda1 result: ${lambda1(3, 5)}")

    val lambda2: (Int, Int) -> Int =
        fun(a, b): Int {
            return a + b
        }
    println("Lambda2 result: ${lambda2(5, 7)}")

    val higherOrderFunction: (Int, Int, (Int, Int) -> Int) -> Int = { a, b, operation ->
        operation(a, b)
    }
    println("Higher-order function result(plus): ${higherOrderFunction(3, 5, {a, b -> a + b})}")
    println("Higher-order function result(multiply): ${higherOrderFunction(3, 5, {a, b -> a * b})}")

    val operation: Operation = { a, b -> a - b }
    println("Typealias Operation result: ${operation(20, 10)}")
}

fun Int.square(): Int = this * this

fun expandFunction() {
    println()
    println("expandFunction")
    println("5 squared: ${5.square()}")
}

fun scopeFunction() {
    println()
    println("scopeFunction")
    val oddNumbers =
        with(mutableListOf<Int>()) {
            for (i in 1..10) {
                if (i % 2 != 0) {
                    // this.add(i)
                    add(i) // thisは省略可
                }
            }
            // this.joinToString(separator = ", ")
            joinToString(separator = ", ") // thisは省略可
        }
    println("Odd numbers: $oddNumbers")

    listOf("Kotlin", null, "Java", null, "Python").run {
        println("Not null languages: ${filterNotNull()}")
    }

    println("hoge"?.let {e -> e.repeat(2)})
    println(null?.let {e -> e.repeat(2)})
    println("fuga"?.let {it.repeat(2)})

    val result1 = listOf(1, 3, 5, 7).apply {
        joinToString(separator = ", ")
    }
    println("Result of apply: $result1")
    val result2 = mutableListOf(1, 3, 5, 7).apply {
        for (i in indices) {
            this[i] *= 2
        }
    }
    println("Result of apply with modification: $result2")

    for (i in listOf(1, null, 3, null, 5)) {
        i?.also { println("Processing number: $it") }
    }
}

fun operatorOverload() {
    println()
    println("operatorOverload")
    val num1 = MyNumber(10)
    val num2 = MyNumber(5)

    println("num1 + num2: ${num1 + num2}")
    println("num1 - num2: ${num1 - num2}")
    println("num1 * num2: ${num1 * num2}")
    println("num1 / num2: ${num1 / num2}")
    println("num1 % num2: ${num1 % num2}")

    println("num1 < num2: ${num1 < num2}")
    println("num1 > num2: ${num1 > num2}")
}
